# Generates a solrconfig.xml based on the properties of model classes.
# This is required for the dismax query handler to operate properly.
SOLR_PATH = "#{File.dirname(File.expand_path(__FILE__))}/../solr" unless defined? SOLR_PATH

module ActsAsSolr
  class Configuration
    include ActsAsSolr::CommonMethods

    require 'erb'

    @@solrconfig_fields = []
    @@schema_fields = []

    def self.build_schema
      c = ActsAsSolr::Configuration.new

      doc = ""
      xml = Builder::XmlMarkup.new(:target => doc, :indent => 2)
      xml.instruct!
      xml.comment!("SOLR schema.xml generated by Searchable.")
      xml.comment!("schema.xml documentation: http://wiki.apache.org/solr/SchemaXml")
      xml.comment!("Searchable: http://mojodna.net/searchable/ruby/")
      xml.schema(:name => 'ActsAsSolr', :version => "1.1") do
        xml.types do
          xml.fieldtype(:name => "string",  :class => "solr.StrField", :sortMissingLast => "true")
          xml.fieldtype(:name => "boolean", :class => "solr.BoolField", :sortMissingLast => "true")
          xml.fieldtype(:name => "integer", :class => "solr.IntField")
          xml.fieldtype(:name => "long",    :class => "solr.LongField")
          xml.fieldtype(:name => "float",   :class => "solr.FloatField")
          xml.fieldtype(:name => "double",  :class => "solr.DoubleField")
          xml.fieldtype(:name => "sint",    :class => "solr.SortableIntField", :sortMissingLast => "true")
          xml.fieldtype(:name => "range_integer",    :class => "solr.SortableIntField", :sortMissingLast => "true")

          xml.fieldtype(:name => "slong",   :class => "solr.SortableLongField", :sortMissingLast => "true")
          xml.fieldtype(:name => "sfloat",  :class => "solr.SortableFloatField", :sortMissingLast => "true")
          xml.fieldtype(:name => "range_float",  :class => "solr.SortableFloatField", :sortMissingLast => "true")

          xml.fieldtype(:name => "sdouble", :class => "solr.SortableDoubleField", :sortMissingLast => "true")
          xml.fieldtype(:name => "date",    :class => "solr.DateField", :sortMissingLast => "true")
          xml.fieldtype(:name => "datetime",:class => "solr.DateField", :sortMissingLast => "true")
          xml.fieldtype(:name => "text_lu", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer do
              xml.tokenizer(:class => "solr.StandardTokenizerFactory")
              xml.filter(:class => "solr.StandardFilterFactory")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.StopFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
          end
          xml.fieldtype(:name  => "text_ws", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
            end
          end
          xml.fieldtype(:name  => "text", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer(:type => "index") do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.WordDelimiterFilterFactory", :generateWordParts => "1",  :generateNumberParts => "1", :catenateWords => "1", :catenateNumbers => "1", :catenateAll => "0")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory", :protected => "protwords.txt")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
            xml.analyzer(:type => "query") do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
              xml.filter(:class => "solr.SynonymFilterFactory", :synonyms => "synonyms.txt", :ignoreCase => "true", :expand => "true")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.WordDelimiterFilterFactory", :generateWordParts => "1", :generateNumberParts => "1", :catenateWords => "0", :catenateNumbers => "0", :catenateAll => "0")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory", :protected => "protwords.txt")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
          end
          xml.fieldtype(:name  => "textTight", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
              xml.filter(:class => "solr.SynonymFilterFactory", :synonyms => "synonyms.txt", :ignoreCase => "true", :expand => "false")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.WordDelimiterFilterFactory", :generateWordParts => "0", :generateNumberParts => "0", :catenateWords => "1", :catenateNumbers => "1", :catenateAll => "0")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory", :protected => "protwords.txt")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
          end

          xml.fieldtype(:name  => "spell", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer(:type => "index") do
              xml.tokenizer(:class => "solr.StandardTokenizerFactory")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
            end
            xml.analyzer(:type => "query") do
              xml.tokenizer(:class => "solr.StandardTokenizerFactory")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.StandardFilterFactory")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
            end
          end
        end



        xml.fields do
          xml.comment!("Core fields")

          xml.field(:name => "id",      :type => "string",   :indexed => "true", :stored => "true")
          xml.field(:name => "pk_i",    :type => "integer",  :indexed => "true", :stored => "true")
          xml.field(:name => "pk_s",    :type => "string",   :indexed => "true", :stored => "true")  
          xml.field(:name => "type",    :type => "string",   :indexed => "true", :stored => "true")                          
          xml.field(:name => "text",    :type => "text",     :indexed => "true", :stored => "false", :multiValued => "true")

          models = c.get_models
          models.each do | m |
            if m.respond_to?(:solr_indexable?) && m.solr_indexable?
              fields = []
              m.configuration[c.solr_classname(m)][:fields].each do |key, field|
                c.make_fields(xml, m, field)
              end
            end
          end
          xml.comment!("Dynamic field mappings for use in to_search_fields")
          xml.dynamicField(:name => "*_i",  :type => "sint",    :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_s",  :type => "string",  :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_l",  :type => "slong",   :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_t",  :type => "text",    :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_b",  :type => "boolean", :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_f",  :type => "sfloat",  :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_d",  :type => "sdouble", :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_dt", :type => "date",    :indexed => "true", :stored => "true")
          xml.field(:name=>"spellword", :type=>"spell", :stored=>"true", :multiValued=>"true", :indexed=>"true", :omitNorms=>"false")

          xml.comment!("Handle active record id fields")
          xml.dynamicField(:name => "*_id", :type => "integer", :indexed => "true", :stored => "true", :multiValued => "true")
          xml.comment!("Wildcard to handle all other fields")
          xml.dynamicField(:name => "*", :type => "text", :indexed => "true", :stored => "false", :multiValued => "true")
        end

        xml.comment!("Unique key for inserts/updates")
        xml.uniqueKey("id")
        xml.defaultSearchField("text")

        xml.comment!("Default fields")
        #klass.field_names.each do |f|
        #  xml.copyField(:source => f, :dest => "_text")
        #end
      end

      doc
    end

    def self.build_solrconfig
      c = ActsAsSolr::Configuration.new
      
      #load in template
      template = ""
      File.open("#{SOLR_PATH}/solr/conf/solrconfig.xml.erb", "r") do |f|
        template = f.read
      end
      models = c.get_models
      fields = ''
      models.each do | m |
        if m.respond_to?(:solr_indexable?) && m.solr_indexable?
          m.configuration[c.solr_classname(m)][:fields].each do |key, field|
            fields = fields + c.make_solrconfig_fields( m, field)
          end
        end
      end
      @fields = fields
      output = ERB.new(template)
      output.result(binding) 
    end


    def get_models
      get_model_names.collect{|class_name| class_name.split('::').inject(Object){ |klass,part| klass.const_get(part) } }
    end

    def get_model_names
      models = []
      Dir.chdir(File.join(RAILS_ROOT, "app/models")) do
        models = Dir["**/*.rb"]
      end
      models.collect{|m | m.sub(/\.rb$/,'').camelize}
    end

    def make_solrconfig_fields(klass, field, stack =[])
      string = ''
      case field.index_type
      when :text, :string
        string = " #{[stack + [field.name]].join("_")}"
      when :association
        association_klass = klass.reflect_on_association(field.name).klass
        if association_klass.respond_to?(:index_attr) && association_klass.configuration[solr_classname(association_klass)][:fields]
          association_klass.configuration[solr_classname(association_klass)][:fields].each do |key, association_field|
            string = string + make_solrconfig_fields(association_klass, association_field, [stack + [field.name]] )
          end
        else
          string = " #{[stack + [field.name]].join("_")}"
        end
      end
      string
    end

    def make_fields(xml, klass, field, stack = [], multivalued=false )
      field_name = [stack + [field.name]].join("_")
      unless @@schema_fields.include?(field_name)
        if field.index_type != :association
          # create basic field
          xml.field(:name => field_name, :type => field.index_type, :termVectors => field.term_vectors?.to_s, :indexed => field.indexed?.to_s, :stored => field.stored?.to_s, :multiValued => (field.multivalued? || multivalued).to_s)
        else
          association_klass = klass.reflect_on_association(field.name).klass
          if association_klass.respond_to?(:index_attr) && association_klass.configuration[solr_classname(association_klass)][:fields]
            # cascade multivalued=true if field is generated through a has_many association.
            multivalued = true if [:has_many, :has_and_belongs_to_many].include?(klass.reflect_on_association(field.name).macro)
            association_klass.configuration[solr_classname(association_klass)][:fields].each do |key, association_field|
              make_fields( xml, association_klass, association_field, [stack + [field.name]], multivalued)
            end
          else
            xml.field(:name => field_name, :type => 'text', :termVectors => field.term_vectors?.to_s, :indexed => field.indexed?.to_s, :stored => field.stored?.to_s, :multiValued => (field.multivalued? || multivalued).to_s)
          end
        end
        # create all appropriate subfields
        field.include.values.each do |subfield|

        end

        # create aliases
        field.aliases.each do |a|
          xml.field(:name => [stack + [a]].join("_"),  :type => field.index_type, :indexed => field.indexed?.to_s, :stored => field.stored?.to_s, :multiValued => field.multivalued?.to_s)

          # create subfields for aliases
          field.include.values.each do |subfield|
            make_fields( xml,  subfield, [stack + [a]] )
          end
        end

        # create sortable field
        xml.field(:name => "_sort-#{field.indexed_name}", :type => "string", :indexed => "false", :stored => true, :multiValued => "true") if field.sortable?
      end
      @@schema_fields << field_name

      xml
    end
  end
end